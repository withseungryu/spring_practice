
# 1장 

## 1. 초난감 DAO 코드
https://withseungryu.tistory.com/66

### 👉 Database와 연동하기 위해 JDBC를 사용할 것인데, 일반적인 순서는 아래와 같습니다.


* DB 연결을 위한 Connection을 가져온다.
* SQL을 담은 Statement(or PreparedStatement)를 만든다.
* 만들어진 Statement를 실행한다.
* 조회의 경우 SQL 쿼리의 실행 결과를 ResultSet으로 받아서 정보를 저장할 오브젝트(User)에 옮겨준다.
* 작업 중에 생성된 Connection, Statement, ResultSet 같은 리소스는 작업을 마친 후 반드시 닫아준다.
* JDBC API가 만들어내는 예외를 잡아서 직접 처리하거나, throws를 선언해 예외가 발생하면 메서드 밖으로 던지게 한다.

### 🧾 정리 

지금까지 간단한 DAO코드를 만들어 보았습니다.

하지만 이 DAO 클래스에는 객체지향 설계 원칙(SOLID)들 중 개방 폐쇄 원칙에 만족하지 못하고 있습니다.



개방 폐쇠 원칙이란?

 '클래스나 모듈은 확장에는 열려 있어야 하고 변경에는 닫혀 있어야 한다'



즉, 이 Dao 클래스를 다양한 클라이언트들이 사용할 텐데,,,,

모든 클라이언트들이 다 같은 DB connect 방식을 사용하지 않을 것입니다.



만약 모든 클라이언트들의 DB connect 방식이 다르다면, 매번 Dao 객체를 고쳐주어야 할 것입니다.



하지만 대부분의 개발자들은 고객에게 소스를 직접 공개하고 싶지 않아 하기 때문에,

클라이언트들이 원하는 DB connection 방식을 아래와 같이 요구에 맞게 생성해줘야 합니다.






## 2. 관심사의 분리

#### 🧐 분리란?
 

프로그래밍의 기초 개념 중 관심사의 분리라는 게 있는데,

 

이를 객체지향에 적용해보면, 관심이 같은 것끼리는 하나의 객체 안으로 또는 친한 객체로 모이게 할 수 있고,

관심이 다른 것은 가능한 한 따로 떨어져서 서로 영향을 주지 않도록 분리하는 것입니다.


#### 👉 템플릿 메소드 패턴 - 스프링이 사랑하는..

 

 슈퍼클래스에 기본적인 로직의 흐름을 만들고, 

 그 기능의 일부를 추상 메소드로 만든 뒤 서브클래스에서 이런 메소드를 필요에 맞게 구현해서

 사용하도록 만드는 방법을 템플릿 메소드 패턴이라고 합니다.
 
### 🧾 정리  (Commit 코드 참조)

분리를 통해 그럴듯한 Dao 객체를 만들어주었습니다.

 

하지만, 아쉽게도 문제점은 남아있습니다.

상속은 다중 상속을 허용하지 않기 때문에 다른 목적으로 UserDao에 상속을 적용하기 힘듭니다.

확장된 기능인 DB Connection을 생성하는 코드를 다른 Dao 클래스에서 적용 할 수 없습니다.

 

이를 위해 DAO에 확장을 적용해야합니다.


## 3. 확장

인터페이스 도입

 

위 문제를 해결하기 위해 상속 대신 인터페이스를 도입해 확장을 해야합니다.

 

#### 💡 인터페이스란?

 '자바가 추상화를 위해 제공하는 가장 유용한 도구' , '어떤 일을 하겠다는 기능만 정의해놓은 코드'

 

인터페이스를 통해 UserDao와 ConnectionMaker간의 서로 긴밀하게 연결되어 있지 않도록 중간에 추상적인 느슨한 연결고리를 만들어줄 수 있습니다.


#### 관계 설정 책임의 분리

 

기존 UserDao의 관심사가 아닌 부분을 서버 부분이 아닌 클라이언트 부분으로 분리를 해주는 것입니다.

즉, 클라이언트 부분에서 UserDao와 관심사가 아닌 부분 간의 오브젝트(객체) 관계를 설정해주는 것입니다.

 

이것이 가능한 이유는 코드에서는 특정 클래스를 전혀 알지 못하더라도 해당 클래스가 구현한 인터페이스를 사용했다면, 그 클래스의 오브젝트를 인터페이스 타입으로 받아서 사용할 수 있기 때문입니다.

 

따라서 두 오브젝트 사이에 런타임 사용관계 또는 링크, 또는 의존관계라고 불리는 관계를 맺어주면 됩니다.


### 🧾 정리 
 

이렇게 만들어진 UserDaoTest - UserDao - ConnectionMaker 구조를

디자인 패턴의 시각으로 전략 패턴(Strategy Pattern)이라 할 수 있습니다.

 

#### 💡 전략 패턴이란?

 

 디자인 패턴의 꼿이라고 불릴 만큼 다양하게 사용되며, 개방 폐쇄 원칙의 실현에도 가장 잘 들어 맞는 패턴입니다.

 전략 패턴은 자신의 기능 맥락에서, 필요에 따라 변경이 필요한 알고리즘을 인터페이스를 통해 외부로 분리시키고,

 이를 구현한 구체적인 알고리즘 클래스를 필요에 따라 바꿔서 사용할 수 있게 하는 디자인 패턴입니다.
 
 
 
 
## 4. 오브젝트 팩토리
 
 
#### 💡 팩토리

 

분리시킬 기능을 담당할 클래스를 만들기 위해,

이 클래스는 객체의 생성 방법을 결정하고 그렇게 만들어진 오브젝트를 돌려주는 것인데,

이 클래스를 팩토리라고 부릅니다.

 

주의해야할 점은 추상 팩토리 패턴이나 팩토리 메소드 패턴과는 다르다는 것을 인지해야합니다.

 

이제 팩토리 클래스의 역할을 하는 DaoFactory 클래스를 만들어보겠습니다.



## 5. IoC

#### 👉 지금까지 대표적인 IoC 프레임워크인 스프링 없이도 IoC 개념을 적용했었는데,

이번에는 스프링 프레임워크를 사용해 IoC 스타일의 애플리케이션을 설계해보겠습니다.

 

스프링의 IoC 핵심은 빈 팩토리(Bean Factroy)와 애플리케이션 컨텍스트(Application Context)가 있습니다.

 

스프링에서는 빈의 생성과 관계설정 같은 제어를 담당하는 IoC 오브젝트를 빈 팩토리라 부릅니다.

그리고 이를 좀 더 확장한 것을 애플리케이션 컨텍스트라고 부릅니다.

 

이 둘의 차이점은 

빈팩토리는 빈을 생성하고 관계를 설정하는 IoC의 기본 기능에 초점을 맞췄고,

애플리케이션 컨텍스트는 애플리케이션 전반에 걸쳐 모든 구성요소의 제어 작업을 담당하는 IoC엔진입니다.

 

#### 💡 빈(Bean)이란?

스프링이 제어권을 가지고 직접 만들고 관계를 부여하는 오브젝트

 

쉽게 말하면, 스프링에서는 애플리케이션 컨텍스트를 IoC컨테이너, 스프링 컨테이너 또는 빈 팩토리라 부릅니다.

(앞으로는 이 둘을 거의 같은 개념이라고 생각하시면 될 것 같다.)

 

 

#### ✏️ 애플리케이션 컨텍스트 사용 

 

애노테이션 @Configuration, @Bean 사용해 빈 팩토리가 DaoFactory를 사용할 수 있도록 만들어줍니다.

 

@Configuration, @Bean이란? 

##### ✏️ 오브젝트 팩토리와 애플리케이션 컨텍스트 동작원리 비교

 

원래 오브젝트 팩토리 방식으로 만든 DaoFactory는 DAO 오브젝트를 생성하고, DB 생성 오브젝트와 관계를 맺어주는

제한적인 역할만 했었습니다.

 

하지만, 애플리케이션 컨텍스트는 애플리케이션에서 IoC를 적용해서 관리할 모든 오브젝트에 대한 생성과 관계 설정을 담당해줍니다.

 

즉, 직접 오브젝트를 생성하고 관계를 맺어주는 코드가 없고, 그런 생성정보와 연관관계 정보를 별도의 설정 정보를 통해 얻습니다.

 

쉽게 말해, 오브젝트 팩토리가 아닌 애플리케이션 컨텍스트를 사용하는 이유는

범용적이고 유연한 방법으로 IoC 기능을 확장하기 위해서입니다.

 


#### ✏️ 애플리케이션 컨텍스트의 장점

*클라이언트는 구체적인 팩토리 클래스를 알 필요가 없다.
*애플리케이션 컨텍스트는 종합 IoC서비스를 제공해준다.
*애플리케이션 컨텍스트는 빈을 검색하는 다양한 방법을 제공한다.

## 6. 싱글톤 레지스트리

#### 💡 싱글톤 패턴이란? 
서버는 하나당 최대로 초당 수십에서 수백 번씩 요청을 받아 처리할 수 있는 높은 성능을 요구하며,

계층형구조로 이뤄진 경우가 대부분이고, 비즈니 로직도 복잡한 경우가 많습니다.

 

이때 매번 요청이 올때마다 로직을 담당하는 오브젝트를 만든다면, 부하가 걸려 서버가 감당하기 힘들것입니다.

(오브젝트의 동일성과 등등성 참고)

 

그래서 서비스 오브젝트라는 개념을 사용해 하나의 오브젝트만 만들어두고, 이를 공유해서 사용하는 방식을 택합니다.

 

이렇게 애플리케이션 안에 제한된 수, 대개 한 개의 오브젝트만 만들엇 사용하는 것이 싱글톤 패턴 원리입니다.

 

#### ✏️ 싱글톤 패턴의 구현 방법

 

*클래스 밖에서는 오브젝트 생성을 못하고, 생성자를 private로 만듭니다.
*생성된 싱글톤 오브젝트를 저장할 수 있는 자신과 같은 타입의 스태틱 필드를 정의해줍니다.
*getInstance()를 만들고 이 메소드가 최초로 호출되는 시점에서 한번만 오브젝트가 만들어지게 해줍니다.
*한번 오브젝트가 만들어지고 난 후 getInstance()를 통해 이미 만들어져 있는 오브젝트를 넘겨줍니다.

#### ✏️ 싱글톤 패턴의 한계

 

*private 생성자를 갖고 있기 때문에 상속할 수 없다.
*싱글톤은 테스트하기가 힘들다.
*서버환경에서는 싱글톤이 하남나 만들어지는 것을 보장하지 못한다.
*싱글톤의 사용은 전역 상태를 만들 수 있기 때문에 바람직하지 못하다.
 

#### 💡 싱글톤 레지스트리란?

스프링은 기본적으로 별다른 설정을 하지 않으면 내부에서 생성하는 빈 오브젝트를 모두 싱글톤으로 만듭니다.

여기서 싱글톤은 디자인 패턴에서 나오는 싱글톤 패턴과 비슷한 개념이지만 구현 방법은 다릅니다.

 

이때 애플리케이션 컨텍스트는 싱글톤을 저장하고 관리하는 싱글톤 레지스트리라고 할 수 있습니다.

 

스프링은 왜 싱글톤으로 빈을 만들까?

스프링은 주로 적용되는 대상이 서버환경이기 때문입니다.

 

그렇기 때문에 스프링은 싱글톤을 적극 지지하지만, 위와 같이 한계가 많이 존재합니다.

 

이에 스프링은 직접 싱글톤 형태의 오브젝트를 만들고 관리하는 기능을 제공하는 싱글톤 레지스트리를 갖고 있습니다.

 

이는 스태틱 메소드와 private 생성자를 사용해야하는 비정상적인 클래스가 아니라 평범한 자바 클래스를

싱글톤으로 활용하게 해줍니다.

 

가장 중요한 것은 싱글톤 패턴과 달리 스프링이 지지하는 객체지향적인 설계 방식의 원칙, 디자인 패턴 등을 적용하는데

아무런 제약이 없게 만들어준다는 것입니다.


## 7. 의존관계 주입

IoC라는 용어는 매우 느슨하게 정의돼서 폭 넓게 사용되는 용어입니다.

그렇기 때문에 몇몇 사람의 제안으로 스프링이 제공하는 IoC방식의 핵심을 짚어주는 명확히 드러나는 이름을 만드는데,

이를 의존관계 주입(Dependency Injection)이라고 합니다.

 

스프링 IoC 기능의 대표적인 동작원리는 주로 의존관계 주입이라고 불립니다.

따라서 IoC컨테이너를 지금은 의존관계 주입 컨테이너, DI 컨테이너라 더 많이 불리고 있습니다.

 

#### ✏️ 의존관계란?

 

누가 누구에게 의존하는 관계에 있다.

 

UML모델에서는 두 클래스의 의존관계를 아래와 같이 표현한다.

#### ✏️ 런타임 의존관계란?

 

오브젝트 의존관계라 불리며, 설계 시점의 의존관계가 실체화되는 것이다.

예를 들어, UserDao의 오브젝트가 런타임 시에 사용할 오브젝트가 어떤 클래스로 만든 것인지 알 수 없다.

사전에 어떤 클래스의 오브젝트를 쓸지 미리 정해놓을 수 있지만, 코드 속에 드러나지 않는다.

 

이때 프로그램이 시작되고 UserDao 오브젝트가 만들어진 후 런타임 시에 의존관계를 맺는 대상을

의존 오브젝트라 말하는데,

 

의존관계 주입은 이렇게 구체적인 의존 오브젝트와 그것을 사용할 주체,

보통 클라이언트라고 부르는 오브젝트를 런타임 시에 연결해주는 작업을 말한다.

 

#### ✏️ 의존관계 조건

 

*클래스 모델이나 코드에는 런타임 시점의 의존관계가 드러나지 않는다.
*인터페이스에만 의존하고 있어야 한다.
*런타임 시점의 의존관계는 컨테이너나 팩토리 같은 제3의 존재가 결정한다.
*의존관계는 오브젝트에 대한 레퍼런스를 외부에서 제공해줘야 한다.
*제3의 존재 : IoC 컨테이너, 애플리케이션 컨텍스트, 빈 팩토리

 

#### ✏️ 의존관계 검색(DL) 이란? 

 

스프링에는 의존관계 주입 뿐 아니라 의존관계 검색도 있다.

 

의존관계를 맺는 방법이 외부로부터의 주입이 아닌, 스스로 검색을 이용한다.

또한 필요로 하는 의존 오브젝트를 능동적으로 찾는다.

 

즉, 런타임 시 의존관계를 맺을 오브젝트를 결정하는 것과 오브젝트의 생성 작업은 외부 컨테이너에게 IoC로 맡기지만,

이를 가져올 때는 메소드나 생성자를 통한 주입 대신 스스로 컨테이너에게 요청하는 방법이다.

 



#### ✏️ 의존관계 주입(DI) VS 의존관계 검색(DL)

 

의존관계 주입이 훨씬 단순하고 깔끔하다.

 

왜냐하면, DL을 사용할 때 코드 안에 오브젝트 팩토리 클래스나 스프링 API가 나타나는데,

애플리케이션 컴포넌트가 컨테이너와 같이 성격이 다른 오브젝트에 의존하게 되는 것이 바람직 하지 않기 때문이다.

 

의존관계 검색은

main() 메소드와 서블릿의 사용자 요청 시 main() 메소드와 비슷한 역할을 하는 곳에 사용해야 적절하다.

 

### 🧾 정리
*DI를 위해 의존관계에 대해 명확히 알아야 한다.
*DI는 IoC의 개념을 더 명확히 한 용어이다.
*DI와 DL 중 DI를 사용하는 것이 훨씬 단순하고 깔끔하다.
 








 
 

